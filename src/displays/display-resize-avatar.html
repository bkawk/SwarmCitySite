<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../bower_components/app-localize-behavior/app-localize-behavior.html">
<link rel="import" href="../../bower_components/iron-media-query/iron-media-query.html">
<link rel="import" href="../../bower_components/paper-slider/paper-slider.html">
<link rel="import" href="../shared-styles.html">

<dom-module id="display-resize-avatar">
    <template>
        <style>
            :host {
                display: block;
                width: 100%;
                max-width: 100vw;
                height: 100%;
            }

            .container {
                width: 100%;
                @apply --layout-vertical;
                @apply --layout-center-center;
            }

            .container[wide-layout] {
                width: 100%;
                @apply --layout-vertical;
                @apply --layout-start;
                @apply --layout-start-justified;
            }

            .container .top {
                width: 100%;
                @apply --layout-vertical;
                @apply --layout-center;
                @apply --layout-start-justified;
                height: 370px;
                margin-bottom: 5vh;
            }

            .container[wide-layout] .top {
                width: 100%;
                @apply --layout-vertical;
                @apply --layout-start;
                @apply --layout-start-justified;
                margin-bottom: 7vh;
            }

            .container .rotate-icon {
                position: relative;
                top: -54px;
                left: 98px;
                margin-bottom: -54px;
                @apply --rotate-blue-normal;
                cursor: pointer;
            }

            .container[wide-layout] .rotate-icon {
                position: relative;
                top: -54px;
                left: 198px;
                margin-bottom: -54px;
                @apply --rotate-blue-normal;
                cursor: pointer;
            }

            .file {
                display: none;
            }

            .bluetext {
                @apply --small-bold;
                cursor: pointer;
                color: var(--sc-blue);
                border-bottom: 2px dotted var(--sc-blue);
                margin: 50px 0px 0px 0px;
            }

            .blacktext {
                @apply --layout-horizontal;
                @apply --layout-center-justified;
                @apply --small-bold;
                color: var(--sc-grey4);
                margin: 10px 0px 0px 0px;
            }

            .container .confirmers {
                @apply --titlepage-confirmers;
            }

            .container[wide-layout] .confirmers {
                @apply --titlepage-confirmers-wide;
            }

            .container .confirmers>div:nth-child(1) {
                @apply --confirmers-x;
                @apply --xmark-grey4-normal;
            }

            .container .confirmers>div:nth-child(1):active {
                @apply --button-active;
            }

            .container .confirmers>div:nth-child(2) {
                @apply --icon-button-big;
            }

            .container .confirmers>div:nth-child(2):active {
                @apply --button-active;
            }

            .container .confirmers>div:nth-child(2)>div:nth-child(1) {
                @apply --vmark-blue-normal;
            }

            @media only screen and (-webkit-min-device-pixel-ratio: 1.5),
            only screen and (min--moz-device-pixel-ratio: 1.5),
            only screen and (min-resolution: 240dpi) {
                .close,
                .rotate-icon,
                .disagree,
                .agree {
                    @apply --retina;
                }
            }
        </style>
        <iron-media-query query="(min-width: 600px)" query-matches="{{wide}}"></iron-media-query>
        <div class="container" wide-layout$="{{wide}}">
            <div class="top">

                <!-- <canvas id="canvas" class="canvas" on-mousemove="_panMove" on-mousedown="_panStart" on-mouseup="_panEnd" on-touchmove="_panMove"
                    on-touchstart="_panStart" on-touchend="_panEnd"></canvas> -->
                <div class="rotate-icon" on-click="_rotate"></div>
                <input type="file" name="file" id="file" class="file" on-change="_fileSelected" accept=".jpg, .jpeg, .png, .gif" />
                <canvas id="canvas" class="canvas" width="{{canvasWidth}}" height="{{canvasHeight}}">Your browser does not support HTML5 Canvas.</canvas>
                <paper-slider id="slider" step="0.01" value="0.5" min="0.0" max="1.0" on-immediate-value-change="_getScale"></paper-slider>{{scale}}
                <div class="blacktext">{{localize('scroll to zoom')}} - {{localize('drag to move')}}</div>

                <label for="file">
                    <p class="bluetext">{{localize('choose another file')}}</p>
                </label>
            </div>

            <div class="bottom">
                <div class="confirmers">
                    <div class="disagree" on-click="_back"></div>
                    <div class="round-button" on-click="_save">
                        <div class="agree"></div>
                    </div>
                </div>
            </div>

        </div>
    </template>
    <script>

        class DisplayResizeAvatar extends new ReduxMixin(Polymer.mixinBehaviors([
            Polymer.AppLocalizeBehavior,
        ],
            Polymer.Element
        )) {
            static get is() {
                return 'display-resize-avatar';
            }
            static get properties() {
                return {
                    /**
                    * Language is the users selected or determined language
                    * @type {String}
                    */
                    language: {
                        type: String,
                        statePath: 'language',
                    },
                    /**
                    * Path signlas to the parent to change the path
                    * @type {Boolean}
                    */
                    path: {
                        type: String,
                        reflectToAttribute: true,
                        notify: true,
                    },
                    /**
                    * Avatar represents the users IPFS to their avatar image
                    * @type {String}
                    */
                    avatar: {
                        type: String,
                        statePath: 'avatar',
                    },
                    /**
                    * routeEntry changes the exact moment pages change when routing
                    * @type {Array}
                    */
                    routeEntry: {
                        type: Array,
                        observer: '_reset',
                    },
                    /**
                    * routeEntry changes the exact moment pages change when routing
                    * @type {Array}
                    */
                    scale: {
                        type: Number,
                        value: 50,
                    },
                    /**
                    * The image
                    * @type {Array}
                    */
                    image: {
                        type: String,
                        observer: '_drawFile'
                    },
                                        /**
                    * The image
                    * @type {Array}
                    */
                    scale: {
                        type: Number,
                        value: 0.5,
                        observer: '_drawFile'
                    },
                    /**
                    * The image
                    * @type {Array}
                    */
                    angle: {
                        type: Number,
                        value: 0,
                        observer: '_drawFile'
                    },
                    /**
                    * The image
                    * @type {Array}
                    */
                    canvasWidth: {
                        type: Number,
                        value: 250,
                    },
                                        /**
                    * The image
                    * @type {Array}
                    */
                    canvasHeight: {
                        type: Number,
                        value: 250,
                    },
                };
            }
            /**
            * Redux action for setting avatar
            * @param {String} avatar
            */
            static get actions() {
                return Object.assign({
                    AVATAR: function(avatar) {
                        return {
                            type: 'AVATAR',
                            avatar: avatar,
                        };
                    },
                });
            }
            /**
            * Fired when the component is connected
            */
            connectedCallback() {
                super.connectedCallback();
                this.loadResources(this.resolveUrl('../text-translations.json'));
            }
            /**
            * Fired when the component is ready
            */
            ready() {
                super.ready();
                if (!this.$.canvas || !this.$.canvas.getContext) {
                    this.context = false;
                } else {
                    this.context = this.$.canvas.getContext("2d");
                    this.context.fillStyle = "#000";
                    this.context.fillRect(0, 0, 250, 250);
                    this.context.save();
                }
            }

            /**
            * Fired when the user selects a file
            * @param {event} event The event from the on-change
            */
            _fileSelected(event) {
                if (this.context && event.target.files && event.target.files[0]) {
                    var fileReader = new FileReader();
                    fileReader.onload = (e) => {
                        var img = new Image();
                        img.addEventListener("load", () => {
                            this.image = img;
                        });
                        img.src = e.target.result;
                    };       
                    fileReader.readAsDataURL(event.target.files[0]);
                }
            }

            _drawFile() {

                if(this.image && this.canvasWidth && this.canvasHeight && this.scale && this.context){
                    console.log('image: ' + this.image);
                    console.log('imageWidth: ' + this.image.width);
                    console.log('imageHeight: ' + this.image.height);
                    console.log('canvasWidth: ' + this.canvasWidth);
                    console.log('canvasHeight' + this.canvasHeight);
                    console.log('scale: ' + this.scale);
                    console.log('angle: ' + this.angle);
                    this.context.translate(this.canvasWidth*0.5, this.canvasHeight*0.5);
                    this.context.scale(this.scale, this.scale);
                    this.context.rotate(this.angle * Math.PI / 180);
                    this.context.drawImage(this.image, -this.image.width*0.5, -this.image.height*0.5);
                    
                }
            }

            _getScale(){
                this.scale = this.$.slider.immediateValue;
            }


            /**
            * Fired when the user selects a file
            * @param {event} event The event from the on-change
            */
            _drawCanvas() {
                let {canvas, ctx, tX, tY, left, top, viewBox,
                    rotations, rotation, paintWidth, paintHeight} = this.mathCanvas;
                let img = this.img || this.defaultImg;
                let width = canvas.width;
                let height = canvas.height;

                ctx.fillStyle = '#333333';
                ctx.clearRect(0, 0, width, height);
                ctx.save();

                // Tom C - Dec 28 2017 - Draw image with pan, zoom, and rotation
                ctx.translate(tX + left, tY + top);
                ctx.rotate(rotations[rotation]);

                ctx.globalAlpha = 1;
                ctx.drawImage(
                    img,
                    viewBox.x,
                    viewBox.y,
                    viewBox.width,
                    viewBox.height,
                    0,
                    0,
                    paintWidth,
                    paintHeight
                );

                ctx.restore();
                ctx.save();

                // Fill with destination composite outside circle
                ctx.globalAlpha = 0.82;

                // Translucent overlay
                ctx.fillRect(0, 0, width, height);

                ctx.restore();
                ctx.save();

                // Redraw image opaque inside of circle
                ctx.beginPath();
                ctx.arc(width / 2, height / 2, Math.min(100, 100) / 2 - 0, 0, 2 * Math.PI, false);
                ctx.clip();

                ctx.globalAlpha = 1;
                ctx.translate(tX + left, tY + top);
                ctx.rotate(rotations[rotation]);

                ctx.drawImage(
                    img,
                    viewBox.x,
                    viewBox.y,
                    viewBox.width,
                    viewBox.height,
                    0,
                    0,
                    paintWidth,
                    paintHeight
                );

                ctx.restore();
                ctx.save();

                // Blue circle
                ctx.beginPath();
                ctx.arc(width / 2, height / 2, Math.min(100, 100) / 2 - 0, 0, 2 * Math.PI, false);
                ctx.closePath();
                ctx.lineWidth = 4;
                ctx.strokeStyle = '#24B1FF';
                // Blue box around perimeter
                ctx.rect(0, 0, width, height);
                ctx.stroke();

                ctx.restore();
            }
            /**
            * Fired when the user is clicking
            * @param {event} e The event from the on-change
            */
            _panStart(e) {
                this.isDown = true;
                this.startX = e.clientX;
                this.startY = e.clientY;
            }
            /**
            * Fired when the user is not clicking
            * @param {event} event The event from the on-change
            */
            _panEnd() {
                this.isDown = false;
                this._drawCanvas();
            }
            /**
            * Fired when the user pans
            * @param {event} e The event from the on-change
            */
            _panMove(e) {
                if (this.isDown) {
                    let diffX = e.clientX - this.startX;
                    let diffY = e.clientY - this.startY;
                    this.mathCanvas.left += diffX;
                    this.mathCanvas.top += diffY;
                    this.startX = e.clientX;
                    this.startY = e.clientY;
                    this._drawCanvas();
                }
            }
            /**
            * Fired when the user selects a file
            * @param {event} event The event from the on-change
            */
            _getFile_BACKUP(event) {
                let image = event.target.files[0];
                event.stopPropagation();
                event.preventDefault();
                if (image.type !== 'image/jpeg'
                    && image.type !== 'image/gif'
                    && image.type !== 'image/png') {
                        alert('Please select an image file of type jpeg, gif, or png ('
                                + image.type + ')');
                        return;
                }
                let img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = function() {
                    this.img = img;
                    this.mathCanvas.size.width = this.mathCanvas.viewBox.width = img.width;
                    this.mathCanvas.size.height = this.mathCanvas.viewBox.height = img.height;
                    this.mathCanvas.reorient();
                    if (img.width == 95 && img.height == 95) {
                        this.mathCanvas.changeZoom(-60);
                    }
                }.bind(this);
                img.src = URL.createObjectURL(image);
            }
            /**
            * Fired when user selects the X back button, routs to previous page
            */
            _back() {
                window.history.back();
            }
            /**
            * Fired when the user selects save
            * @param {event} event The event from the on-change
            */
            _save() {
                const canvas = this.$.canvas;
                const jpegUrl = canvas.toDataURL('image/jpeg');
                // make a new canvas
                let newCanvas = document.createElement('canvas');
                newCanvas.width = 95;
                newCanvas.height = 95;
                let ctx = newCanvas.getContext('2d');
                let image = new Image();
                image.onload = () => {
                    ctx.drawImage(image, -77, -77);
                    const avatarUrl = newCanvas.toDataURL('image/jpeg');
                    let storage = JSON.parse(localStorage.getItem('SwarmCity'));
                    this.dispatch('AVATAR', avatarUrl);
                    storage.user.avatar = avatarUrl;
                    localStorage.setItem('SwarmCity', JSON.stringify(storage));
                    window.history.back();
                };
                image.src = jpegUrl;
            }
            /**
            * Fired when the page routes away, all image values are reset
            * @param {event} event The event from the on-change
            */
            _reset() {
                if (this.routeEntry.includes('resize-avatar')) {
                    const canvas = this.$.canvas;
                    const img = new Image();
                    const draw = this._drawCanvas.bind(this);
                    img.crossOrigin = 'anonymous';
                    canvas.width = 250;
                    canvas.height = 250;
                    this.img = this.defaultImg = img;
                    img.onload = function() {
                        let nonaf = this.mathCanvas = mathCanvas({
                            canvas,
                            draw,
                            noBounds: true,
                            size: {width: img.width, height: img.height},
                            viewBox: {x: 0, y: 0, width: img.width, height: img.height},
                        });

                        if (img.width == 95 && img.height == 95) {
                            nonaf.changeZoom(-60);
                        }
                        draw();
                        addWheelListener(canvas, function (e) { // eslint-disable-line
                            e.preventDefault();

                            // tc 12-15-2017
                            nonaf.setCenter(-window.pageXOffset + canvas.offsetLeft + canvas.width/2,
                                            -window.pageYOffset + canvas.offsetTop + canvas.height/2);
                            if (nonaf.zoomFactor > .25 && e.deltaY > 0) {
                                nonaf.changeZoom(-5);
                            }

                            if (nonaf.zoomFactor < 1.75 && e.deltaY < 0) {
                                nonaf.changeZoom(5);
                            }

                            // nonaf.changeZoom(e.deltaY > 0 ? -5 : 5);
                        });
                    }.bind(this);
                    img.src = this.avatar;
                }
            }
            /**
            * Fired when the user selects a rotate
            * @param {event} event The event from the on-change
            */
            _rotate() {
                this.mathCanvas.rotate(1);
            }
            /**
            * Fired when the user selects a zoom in
            * @param {event} event The event from the on-change
            */
            _zoomin() {
                this.mathCanvas.changeZoom(4);
            }
            /**
            * Fired when the user selects a zoom out
            * @param {event} event The event from the on-change
            */
            _zoomout() {
                this.mathCanvas.changeZoom(-4);
            }
        } window.customElements.define(DisplayResizeAvatar.is, DisplayResizeAvatar);
    </script>
</dom-module>
