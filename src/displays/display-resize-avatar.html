<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../bower_components/app-localize-behavior/app-localize-behavior.html">
<link rel="import" href="../../bower_components/iron-media-query/iron-media-query.html">
<link rel="import" href="../../bower_components/paper-slider/paper-slider.html">
<link rel="import" href="../shared-styles.html">

<dom-module id="display-resize-avatar">
    <template>
        <style>
            :host {
                display: block;
                width: 100%;
                max-width: 100vw;
                height: 100%;
            }

            .container {
                width: 100%;
                @apply --layout-vertical;
                @apply --layout-center-center;
            }

            .container[wide-layout] {
                width: 100%;
                @apply --layout-vertical;
                @apply --layout-start;
                @apply --layout-start-justified;
            }

            .container .top {
                width: 100%;
                @apply --layout-vertical;
                @apply --layout-center;
                @apply --layout-start-justified;
                height: 370px;
                margin-bottom: 5vh;
            }

            .container[wide-layout] .top {
                width: 100%;
                @apply --layout-vertical;
                @apply --layout-start;
                @apply --layout-start-justified;
                margin-bottom: 7vh;
            }

            .container .rotate-icon {
                position: relative;
                top: -54px;
                left: 98px;
                margin-bottom: -54px;
                @apply --rotate-blue-normal;
                cursor: pointer;
            }

            .container[wide-layout] .rotate-icon {
                position: relative;
                top: -54px;
                left: 198px;
                margin-bottom: -54px;
                @apply --rotate-blue-normal;
                cursor: pointer;
            }

            .file {
                display: none;
            }

            .bluetext {
                @apply --small-bold;
                cursor: pointer;
                color: var(--sc-blue);
                border-bottom: 2px dotted var(--sc-blue);
                margin: 50px 0px 0px 0px;
            }

            .blacktext {
                @apply --layout-horizontal;
                @apply --layout-center-justified;
                @apply --small-bold;
                color: var(--sc-grey4);
                margin: 10px 0px 0px 0px;
            }

            .container .confirmers {
                @apply --titlepage-confirmers;
            }

            .container[wide-layout] .confirmers {
                @apply --titlepage-confirmers-wide;
            }

            .container .confirmers>div:nth-child(1) {
                @apply --confirmers-x;
                @apply --xmark-grey4-normal;
            }

            .container .confirmers>div:nth-child(1):active {
                @apply --button-active;
            }

            .container .confirmers>div:nth-child(2) {
                @apply --icon-button-big;
            }

            .container .confirmers>div:nth-child(2):active {
                @apply --button-active;
            }

            .container .confirmers>div:nth-child(2)>div:nth-child(1) {
                @apply --vmark-blue-normal;
            }

            @media only screen and (-webkit-min-device-pixel-ratio: 1.5),
            only screen and (min--moz-device-pixel-ratio: 1.5),
            only screen and (min-resolution: 240dpi) {
                .close,
                .rotate-icon,
                .disagree,
                .agree {
                    @apply --retina;
                }
            }
        </style>
        <iron-media-query query="(min-width: 600px)" query-matches="{{wide}}"></iron-media-query>
        <div class="container" wide-layout$="{{wide}}">
            <div class="top">

                <div class="rotate-icon" on-click="_rotate"></div>
                <input type="file" name="file" id="file" class="file" on-change="_fileSelected" accept=".jpg, .jpeg, .png, .gif" />
                <canvas id="canvas" class="canvas" width="{{canvasWidth}}" height="{{canvasHeight}}"
                        on-mousedown="_panStart" on-mouseup="_panEnd" on-mousemove="_panMove"
                        on-touchstart="_panStart" on-touchend="_panEnd" on-touchmove="_panMove"
                        ontouchstart="_panStart" ontouchend="_panEnd" ontouchmove="_panMove"
                        onmousewheel="{{_zoom}}"
                        >Your browser does not support HTML5 Canvas.</canvas>
                <paper-slider id="slider" step="0.01"  min="0.0" max="1.0" on-change="{{_getScale}}" value="{{scale}}" editable="true" on-immediate-value-change="_getScale"></paper-slider>
                <div class="blacktext">{{localize('scroll to zoom')}} - {{localize('drag to move')}}</div>

                <label for="file">
                    <p class="bluetext">{{localize('choose another file')}}</p>
                </label>
            </div>

            <div class="bottom">
                <div class="confirmers">
                    <div class="disagree" on-click="_back"></div>
                    <div class="round-button" on-click="_save">
                        <div class="agree"></div>
                    </div>
                </div>
            </div>

        </div>
    </template>
    <script>

        class DisplayResizeAvatar extends new ReduxMixin(Polymer.mixinBehaviors([
            Polymer.AppLocalizeBehavior,
        ],
            Polymer.Element
        )) {
            static get is() {
                return 'display-resize-avatar';
            }
            static get properties() {
                return {
                    /**
                    * Language is the users selected or determined language
                    * @type {String}
                    */
                    language: {
                        type: String,
                        statePath: 'language',
                    },
                    /**
                    * Path signlas to the parent to change the path
                    * @type {Boolean}
                    */
                    path: {
                        type: String,
                        reflectToAttribute: true,
                        notify: true,
                    },
                    /**
                    * Avatar represents the users IPFS to their avatar image
                    * @type {String}
                    */
                    avatar: {
                        type: String,
                        statePath: 'avatar',
                    },
                    /**
                    * routeEntry changes the exact moment pages change when routing
                    * @type {Array}
                    */
                    routeEntry: {
                        type: Array,
                        observer: '_reset',
                    },
                    /**
                    * The image
                    * @type {Image}
                    */
                    image: {
                        type: Image,
                        observer: '_drawFile',
                    },
                                        /**
                    * scale
                    * @type {Number}
                    */
                    scale: {
                        type: Number,
                        value: 0.5,
                        observer: '_drawFile',
                    },
                    /**
                    * angle
                    * @type {Number}
                    */
                    angle: {
                        type: Number,
                        value: 0,
                        observer: '_drawFile',
                    },
                    /**
                    * canvasWidth
                    * @type {Number}
                    */
                    canvasWidth: {
                        type: Number,
                        value: 250,
                    },
                    /**
                    * canvaseHeight
                    * @type {Number}
                    */
                    canvasHeight: {
                        type: Number,
                        value: 250,
                    },
                    /**
                    * panX x offset for image within canvas
                    * @type {Number}
                    */
                    panX: {
                        type: Number,
                        value: 0,
                    },
                    /**
                    * panY y offset for image within canvas
                    * @type {Number}
                    */
                    panY: {
                        type: Number,
                        value: 0,
                    },
                    /**
                    * mouse down x offset for image within canvas
                    * @type {Number}
                    */
                    startX: {
                        type: Number,
                        value: 0,
                    },
                    /**
                    * mousedown y offset for image within canvas
                    * @type {Number}
                    */
                    startY: {
                        type: Number,
                        value: 0,
                    },
                    /**
                    * mouse is/isn't down
                    * @type {Boolean}
                    */
                    isDown: {
                        type: Boolean,
                        value: 0,
                    },
                };
            }
            /**
            * Redux action for setting avatar
            * @param {String} avatar
            */
            static get actions() {
                return Object.assign({
                    AVATAR: function(avatar) {
                        return {
                            type: 'AVATAR',
                            avatar: avatar,
                        };
                    },
                });
            }
            /**
            * Fired when the component is connected
            */
            connectedCallback() {
                super.connectedCallback();
                this.loadResources(this.resolveUrl('../text-translations.json'));
            }
            /**
            * Fired when the component is ready
            */
            ready() {
                super.ready();
                // if (!this.$.canvas || !this.$.canvas.getContext) {
                //     this.context = this.$.canvas.getContext('2d');
                // }

                this.context = this.$.canvas.getContext('2d');

                super.ready();
                const canvas = this.$.canvas;
                const img = new Image();
                const draw = this._drawFile.bind(this);
                img.crossOrigin = 'anonymous';
                canvas.width = 250;
                canvas.height = 250;
                img.src = this.avatar;
                img.onload = () => {
                    draw();
                };

                this.image.src = this.avatar;
            }

            /**
            * Fired when the user selects a file
            * @param {event} event The event from the on-change
            */
            _fileSelected(event) {
                if (this.context && event.target.files && event.target.files[0]) {
                    let fileReader = new FileReader();
                    fileReader.onload = (e) => {
                        let img = new Image();
                        img.addEventListener('load', () => {
                            this.image = img;
                        });
                        img.src = e.target.result;
                    };
                    fileReader.readAsDataURL(event.target.files[0]);
                }
            }

            _drawFile() {
                if (!this.context) {
                    this.context = this.$.canvas.getContext('2d');
                }

                if (this.canvasWidth && this.canvasHeight && this.scale) {
                    let ctx = this.context;
                    let width = this.canvasWidth;
                    let height = this.canvasHeight;
                    let px = this.panX * (2 + (1-this.scale));
                    let py = this.panY * (2 + (1-this.scale));
                    let rad = this.angle * Math.PI / 180;
                    let nx = px;
                    let ny = py;

                    // Rotate point
                    nx = px * Math.cos(-rad) - py * Math.sin(-rad);
                    ny = px * Math.sin(-rad) + py * Math.cos(-rad);

                    this.context.fillStyle = '#000';
                    ctx.globalAlpha = 1;
                    this.context.fillRect(0, 0, this.canvasWidth, this.canvasHeight);
                    this.context.save();
                    this.context.translate(this.canvasWidth * 0.5, this.canvasHeight * 0.5);
                    this.context.scale(this.scale, this.scale);
                    this.context.rotate(this.angle * Math.PI / 180);
                    this.image && this.context.drawImage(this.image, -this.image.width * 0.5 + nx,
                                -this.image.height * 0.5 + ny);

                    // Fill with destination composite outside circle
                    // Translucent overlay

                    // remove translate, rotate, scale
                    ctx.restore();
                    ctx.globalAlpha = 0.5;
                    ctx.fillRect(0, 0, width, height);
                    ctx.save();

                    // Redraw image opaque inside of circle
                    ctx.beginPath();
                    ctx.arc(width / 2, height / 2, Math.min(100, 100) / 2 - 0, 0, 2 * Math.PI, false);
                    ctx.clip();

                    // Re-establish image context for the inner circle opaque image
                    ctx.globalAlpha = 1;
                    this.context.translate(this.canvasWidth*0.5, this.canvasHeight*0.5);
                    this.context.scale(this.scale, this.scale);
                    this.context.rotate(this.angle * Math.PI / 180);
                    this.image && this.context.drawImage(this.image, -this.image.width * 0.5 + nx,
                                -this.image.height * 0.5 + ny);

                    ctx.restore();
                }
            }
            _getScale() {
                this.scale = this.$.slider.immediateValue;
                // console.log("getScale called .. scale: " + this.scale + " val: "
                                // + this.$.slider.immediateValue);
                // this._drawFile();
            }
            _rotate() {
                this.angle = this.angle + 45;
                if (this.angle > 315) {
                    this.angle = 0;
                }
            }
            /**
            * Fired when the user is clicking
            * @param {e} e The event from the on-change
            */
            _panStart(e) {
                this.isDown = true;
                this.startX = e.clientX - this.panX;
                this.startY = e.clientY - this.panY;
            }
            /**
            * Fired when the user is not clicking
            * @param {e} e event The event from the on-change
            */
            _panEnd(e) {
                this.isDown = false;
                // this.panX = this.startX - e.clientX;
                // this.panY = this.startY - e.clientY;
                // this.panX = e.clientX - this.startX;
                // this.panY = e.clientY - this.startY;
                this._drawFile();
            }
            /**
            * Fired when the user pans
            * @param {e} e The event from the on-change
            */
            _panMove(e) {
                if (this.isDown) {
                    // let diffX = e.clientX - this.panX;
                    // let diffY = e.clientY - this.panY;
                    // this.mathCanvas.left += diffX;
                    // this.mathCanvas.top += diffY;
                    this.panX = e.clientX - this.startX;
                    this.panY = e.clientY - this.startY;
                    this._drawFile();
                }
            }
            _zoom(e) {
                e.preventDefault();
                this.scale = e.deltaY > 0 ? this.scale + .1 : this.scale - .1;
                // this._drawFile();
                // this._getScale();
            }

            /**
            * Fired when user selects the X back button, routs to previous page
            */
            _back() {
                window.history.back();
            }
            /**
            * Fired when the user selects save
            * @param {event} event The event from the on-change
            */
            _save() {
                const canvas = this.$.canvas;
                const jpegUrl = canvas.toDataURL('image/jpeg');
                // make a new canvas
                let newCanvas = document.createElement('canvas');
                newCanvas.width = 95;
                newCanvas.height = 95;
                let ctx = newCanvas.getContext('2d');
                let image = new Image();
                image.onload = () => {
                    ctx.drawImage(image, -77, -77);
                    const avatarUrl = newCanvas.toDataURL('image/jpeg');
                    let storage = JSON.parse(localStorage.getItem('SwarmCity'));
                    this.dispatch('AVATAR', avatarUrl);
                    storage.user.avatar = avatarUrl;
                    localStorage.setItem('SwarmCity', JSON.stringify(storage));
                    window.history.back();
                };
                image.src = jpegUrl;
            }
            /**
            * Fired when the page routes away, all image values are reset
            * @param {event} event The event from the on-change
            */
            _reset() {
                if (this.routeEntry.includes('resize-avatar')) {
                    const canvas = this.$.canvas.getContext('2d');
                    const img = new Image();
                    const draw = this._drawFile.bind(this);
                    img.crossOrigin = 'anonymous';
                    canvas.width = this.canvasWidth;
                    canvas.height = this.canvasHeight;
                    this.image = this.defaultImg = img;
                    img.onload = function() {
                        // if (img.width == 95 && img.height == 95) {
                        // nonaf.changeZoom(-60);
                        // }
                        // addWheelListener(canvas, function (e) { // eslint-disable-line
                        // e.preventDefault();

                        // tc 12-15-2017
                        // nonaf.setCenter(-window.pageXOffset + canvas.offsetLeft + canvas.width / 2,
                        //                 -window.pageYOffset + canvas.offsetTop + canvas.height / 2);
                        // if (nonaf.zoomFactor > .25 && e.deltaY > 0) {
                        //     nonaf.changeZoom(-5);
                        // }

                        // if (nonaf.zoomFactor < 1.75 && e.deltaY < 0) {
                        //     nonaf.changeZoom(5);
                        // }

                        // nonaf.changeZoom(e.deltaY > 0 ? -5 : 5);
                        // });
                        draw();
                    };
                    this.image.src = this.avatar;
                    draw();
                }
            }
        } window.customElements.define(DisplayResizeAvatar.is, DisplayResizeAvatar);
    </script>
</dom-module>
